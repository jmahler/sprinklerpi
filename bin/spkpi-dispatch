#!/usr/bin/perl
use strict;

use Linux::Inotify2;
use YAML qw(LoadFile);

=head1 NAME

spkpi-dispatch - dispatch mode specific daemons

=head1 DESCRIPTION

This program monitors the mode file in the sprinklerpi files
directory and runs the correct daemon for that mode.
There can be only one mode at a time so there can be only
one daemon at a time.  This program will kill any currently
running daemon before starting a new one.

    sprinklerpi/mode

The sprinklerpi files directory must be known.
The default is "../sprinklerpi" but this can be overriden
by specifying it as the first argument.

    spkpi-dispatch "../sprinklerpi"

=head1 AUTHOR

    Jeremiah Mahler <jmmahler@gmail.com>
    http://github.com/jmahler

=head1 COPYRIGHT

Copyright (c) 2014, Jeremiah Mahler. All Rights Reserved.
This module is free software.  It may be used, redistributed
and/or modified under the same terms as Perl itself.

=cut

my $dir = '../sprinklerpi';  # default
if (@ARGV) {
	$dir = shift @ARGV;
}

(-e $dir)
	or die "Required directory '$dir' does not exist!";

my $conf_file = "$dir/sprinklerpi.conf";

(-e "$conf_file")
	or die "Configuration file '$conf_file' does not exist!";

my $cfg = LoadFile($conf_file);
$cfg->{dir} = $dir;

$cfg->{mode_file} = $cfg->{dir} . "/mode";

# make sure the mode file exists and can be read
(-e $cfg->{mode_file})
	or die "Mode file '" . $cfg->{mode_file} . "' does not exist!";
(-r $cfg->{mode_file})
	or die "Mode file '" . $cfg->{mode_file} . "' cannot be read.!";

# make sure the mode programs are valid and can be executed
foreach my $mode (keys %{$cfg->{modes}}) {
	my $_prog = $cfg->{modes}{$mode};

	my $prog = `which $_prog`;
	chomp($prog);
	if ($?) {
		die "Program '$_prog' for mode '$mode' cannot be found or is not executable!";
	}

	(-e $prog)
		or die "Program '$prog' for mode '$mode' does not exist!";
	(-r $prog)
		or die "Program '$prog' for mode '$mode' cannot be read!";
	(-x $prog)
		or die "Program '$prog' for mode '$mode' is not executable!";
}

# setup file notifications
my $inotify = new Linux::Inotify2
	or die "Unable to create inotify object: $!";
my $watch = $inotify->watch($cfg->{mode_file}, IN_CLOSE_WRITE)
	or die "Unable to create watch: $!";

# quit gracefully without zombie children
my $quit = 0;
my $sub_quit = sub { $quit = 1; };
$SIG{INT} = $sub_quit;  # ctrl-c
$SIG{TERM} = $sub_quit;

my $child_pid = 0;
my $firstpass = 1;
while (1) {
	# first time, or just got a notify of a file change
	if (! $firstpass) {
		print "Waiting for file change on '" . $cfg->{mode_file} . "'\n"
				if $cfg->{verbose};
		$inotify->poll;
	} else {
		$firstpass = 0;
	}

	# kill any currently running children
	if ($child_pid) {
		print "Child pid: $child_pid\n" if $cfg->{verbose};
		do {
			print "  Kill TERM $child_pid\n" if $cfg->{verbose};
			kill 'TERM', $child_pid;
		} while (-1 != wait);
		print "  no more children\n" if $cfg->{verbose};
	}

	last if ($quit);

	# read the mode
	my $mode_file = $cfg->{mode_file};
	unless (open(MF, "< $mode_file")) {
		print STDERR "Unable to open file '$mode_file': $!\n";	
		print STDERR "  skipping.\n";
		next;
	}
	my $mode = <MF>;
	chomp($mode);
	close(MF);

	# make sure the mode is valid
	my $prog;
	if (exists $cfg->{modes}{$mode}) {
		$prog = $cfg->{modes}{$mode};
	} else {
		my $modes = join ", ", (keys $cfg->{modes});
		print STDERR "Unsupported mode '$mode'\n";
		print STDERR "  Valid modes are: $modes\n";
		print STDERR "  skipping\n";
		next;
	}

	# exec the process for this mode
	$child_pid = fork();
	if (! defined $child_pid) {
		# error
		print STDERR "Couldn't fork: $!";
		next;
	} elsif ($child_pid) {
		# parent
		print "Forked child: $child_pid\n" if $cfg->{verbose};
	} else {
		# child
		unless (exec ($prog)) {
			print STDERR "Couldn't exec $prog $!";
			exit(1);
		}
	}
}
