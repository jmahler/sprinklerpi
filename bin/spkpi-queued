#!/usr/bin/perl
use strict;

use YAML::Syck;

=head1 NAME

spkpi-queued - SprinklerPI queue daemon.

=head1 DESCRIPTION

The queue daemon monitors a the queue files and controls which valve
to turn on by writing the valve number to the valve file for that group.

  queue/group-1
  queue/group-2
  queue/group-3

  valves/group-1
  valves/group-2
  valves/group-3

The format of the queue file is as follows with each entry on one line.

  <valve> <time seconds>

An example queue might look like:

  1 60
  1 900
  2 15

To check the operation of this daemon queue entries can be written
from the command line.

  echo "1 60" >> queue/group-2

If nothing else is running, the valve should be turned on.

  cat valves/group-2
  1

=head1 AUTHOR

    Jeremiah Mahler <jmmahler@gmail.com>
    http://github.com/jmahler

=head1 COPYRIGHT

Copyright (c) 2014, Jeremiah Mahler. All Rights Reserved.
This module is free software.  It may be used, redistributed
and/or modified under the same terms as Perl itself.

=cut

# {{{ valve_on
sub valve_on {
	my ($valve_file, $valve) = @_;

	unless (open(FILE, ">", $valve_file)) {
		print STDERR "Error opening '$valve_file': $!";
		return;
	}

	print FILE $valve;

	close(FILE);
}
# }}}

# {{{ pop_queue
sub pop_queue {
	my ($queue_file) = @_;

	unless (open(IN, "<", $queue_file)) {
		print STDERR "Error opening '$queue_file': $!";
		return;
	}

	my @queue = <IN>;

	close(IN);

	my $first_line = shift @queue;
	chomp($first_line);

	unless (open(OUT, ">", $queue_file)) {
		print STDERR "Error opening '$queue_file': $!";
		return;
	}

	print OUT @queue;

	close(OUT);

	unless (defined $first_line and $first_line ne '') {
		return ();
	}

	print "line = '$first_line'\n";
	my ($valve, $time) = split /\s+/, $first_line;
	print "valve=$valve, time=$time\n";

	return ($valve, $time);
}
# }}}

my $dir = '../sprinklerpi';  # default
if (@ARGV) {
	$dir = shift @ARGV;
}

(-e $dir)
	or die "Required directory '$dir' does not exist!";

my $conf_file = "$dir/sprinklerpi.conf";

(-e "$conf_file")
	or die "Configuration file '$conf_file' does not exist!";

my $cfg = LoadFile($conf_file);

# Turn off valves after a Ctrl-C quit
$SIG{'INT'} = sub {
	for (my $i = 1; $i <= 3; $i++) {
		my $valve_file = "$dir/valves/group-$i";
		valve_on($valve_file, "0");
	}

	exit();
};

my $time_left = {
	'group-1' => 0,
	'group-2' => 0,
	'group-3' => 0,
};

my $last_time = time;
while (1) {

	my $cur_time = time;
	my $dt = $cur_time - $last_time;
	for (my $i = 1; $i <= 3; $i++) {
		my $queue_file = "$dir/queue/group-$i";
		my $valve_file = "$dir/valves/group-$i";

		# update time left
		my $t = $time_left->{"group-$i"};
		$t = ($t > $dt) ? ($t - $dt) : 0;
		$time_left->{"group-$i"} = $t;
		print "[$i] time left = $t\n" if $cfg->{verbose};

		# if time zero, add from the queue
		if (0 == $t) {
			my ($valve, $time) = pop_queue($queue_file);
			if (defined $valve and $valve ne '') {
				print "valve_on('$valve_file', '$valve')\n" if $cfg->{verbose};
				valve_on($valve_file, $valve);
				$t = $time;
				print "[$i] time left = $t\n" if $cfg->{verbose};
				$time_left->{"group-$i"} = $t;
			} else {
				valve_on($valve_file, "0");
				print "queue for group $i empty\n" if $cfg->{verbose};
			}
		}
	}
	$last_time = $cur_time;

	sleep 5;
}
